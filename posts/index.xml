<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Dominik Labudzinski</title><link>https://labudzinski.com/posts/</link><description>Recent content in Posts on Dominik Labudzinski</description><generator>Hugo -- gohugo.io</generator><language>pl-pl</language><lastBuildDate>Sat, 11 Jun 2022 09:45:32 +0200</lastBuildDate><atom:link href="https://labudzinski.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Szyfrowanie plików w trakcie przesyłania do aplikacji Effiana DAM+</title><link>https://labudzinski.com/posts/szyfrowanie-plik%C3%B3w-w-trakcie-przesy%C5%82ania/</link><pubDate>Sat, 11 Jun 2022 09:45:32 +0200</pubDate><guid>https://labudzinski.com/posts/szyfrowanie-plik%C3%B3w-w-trakcie-przesy%C5%82ania/</guid><description>&lt;p>Dzisiaj skupimy się na sposobach przesyłania i przechowywania wrażliwych plików. Dlaczego? Każdego dnia BrandOriented, wdrażając system Effiana, ułatwia pracę zespołom komercyjnym w ich codziennych obowiązkach, m.in. wspierając decyzje, integrując dane w środowisku rozproszonym, jak i wspierając procesy wewnątrz organizacji. Effiana w odczuwalny sposób zmienia niemal każdy aspekt pracy zespołów oraz ich wyniki.
Istnieje jednak wiele mechanizmów, które nie są widoczne dla użytkowników, a które odpowiadają za niezwykle ważny obszar — bezpieczeństwo. Tak jest m.in. z szyfrowaniem plików, które omówimy poniżej.&lt;/p></description><content type="html"><![CDATA[<p>Dzisiaj skupimy się na sposobach przesyłania i przechowywania wrażliwych plików. Dlaczego? Każdego dnia BrandOriented, wdrażając system Effiana, ułatwia pracę zespołom komercyjnym w ich codziennych obowiązkach, m.in. wspierając decyzje, integrując dane w środowisku rozproszonym, jak i wspierając procesy wewnątrz organizacji. Effiana w odczuwalny sposób zmienia niemal każdy aspekt pracy zespołów oraz ich wyniki.
Istnieje jednak wiele mechanizmów, które nie są widoczne dla użytkowników, a które odpowiadają za niezwykle ważny obszar — bezpieczeństwo. Tak jest m.in. z szyfrowaniem plików, które omówimy poniżej.</p>
<p>Zanim zaczniemy przygotowywać się do szyfrowania plików, musimy zaplanować cały proces, a możliwości jest wyjątkowo dużo, zarówno jeżeli chodzi o algorytmy szyfrowania, jak i metody przetwarzania zaszyfrowanych plików. Na potrzeby tego materiału skupimy się na metodzie szyfrowania podobnej do tej, którą stosujemy w systemie Effiana, natomiast pokażemy ją oczywiście w dużym uproszczeniu. Przykłady mają na celu przybliżenie sposobu działania mechanizmu, a nie rzeczywistego kodu. Metoda ta zakłada, że pliki trafiają do serwera już w formie zaszyfrowanej, a dostęp do nich jest ograniczony do wybranych osób i nie wymaga ponownego szyfrowania na skutek zmiany odbiorców. Przykłady będą stanowiły pewnego rodzaju ideę, której sposoby implementacji mogą się znacznie różnić od siebie.
Zacznijmy zatem od prostego kodu wysyłającego pliki do serwera z przeglądarki użytkownika:</p>
<pre tabindex="0"><code>function upload() {
    const file = document.getElementById(&#34;file&#34;).files[0];
    fetch(&#39;/upload&#39;, {
        method: &#39;PUT&#39;,
        body: file
    });
}
</code></pre><p>Powyższy kod wysyła plik do serwera w najprostszy możliwy sposób bez szyfrowania. Naszym celem jest jednak przesyłanie zaszyfrowanego pliku, który nigdy nie trafi do serwera w postaci jawnej. Dodajmy zatem do funkcji zapisującej plik mechanizm szyfrowania, w tym celu użyjmy biblioteki cryptojs:</p>
<pre tabindex="0"><code>function upload() {
    const file = document.getElementById(&#34;file&#34;).files[0];
    saveFile(file);
}
async function saveFile (file) {
  const reader = new FileReader();
  reader.addEventListener(&#34;load&#34;, () =&gt; {
        fetch(&#39;/upload&#39;, {
            method: &#39;PUT&#39;,
            body: CryptoJS.AES.encrypt(reader.result, &#34;&lt;pass&gt;&#34;)
        });
    }, false);
    if (file) {
       reader.readAsText(file);
    }
}
</code></pre><p>W takiej formie funkcja saveFile wyśle plik zaszyfrowany bezpośrednio do serwera. Powyższy przykład zawiera jednak poważny błąd. Kluczem szyfrującym jest zapisane w kodzie hasło. Oczywiście można użyć w tym miejscu różnych mechanizmów, tj. sesje, czy cookie, natomiast w dalszym ciągu będzie to mało bezpieczne, gdyż hasło, którym zaszyfrujemy nasz plik, będzie w dalszym ciągu jedynym zabezpieczeniem. W tym celu zastosujemy szyfrowanie asymetryczne RSA i użyjemy biblioteki cryptico, a na potrzeby tego artykułu zapiszemy klucz publiczny w kodzie — docelowo powinien on być zwracany z serwera, ale na tym etapie przyjmijmy, że tak jest.</p>
<pre tabindex="0"><code>const publicKeyString = &#39;MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgGFxQyrqquJh+W/5wtrD3lrEWaCp
EDjcHreBGU37v58GB2i3Vl/3VBP1KUqlVmkre/iAXSOKKKnS2k8cqftPZMGf8+r6
BJKX7PJkKIEDkxBjReoaIZsibqGEKYF1ZLKmrvXlBO2+EyMvymv8A8QnJtHWdznw
yitAM25LKNRnPVWbAgMBAAE=&#39;;
function upload() {
    const file = document.getElementById(&#34;file&#34;).files[0];
    saveFile(file);
}
async function saveFile (file) {
  const reader = new FileReader();
  reader.addEventListener(&#34;load&#34;, () =&gt; {
        fetch(&#39;/upload&#39;, {
            method: &#39;PUT&#39;,
            body: cryptico.encrypt(
                   reader.result, publicKeyString
               ).cipher
        });
    }, false);
    if (file) {
       reader.readAsText(file);
    }
}
</code></pre><p>Podsumowując, mamy już mechanizm, który szyfruje nam plik, zanim trafi on do serwera, używamy w tym celu szyfrowania asymetrycznego RSA, który do szyfrowania używa klucza publicznego, a do odszyfrowania klucza prywatnego. Pora zatem przejść na drugą stronę i przyjrzeć się jak po stronie serwera wyglądać będzie cały mechanizm.
Na początku musimy wygenerować parę kluczy i tu pojawia się ważne pytanie:
Czy każdy przesyłany plik powinien być szyfrowany tym samym kluczem?
Odpowiedź jest tylko teoretycznie prosta, gdyż w zależności od tego, jaka zostanie udzielona zależy to, czy wymagać będzie dodatkowego nakładu pracy i zasobów. Zespoły developerskie często starają się tworzyć rozwiązania jak najmniejszym nakładem pracy, co w przypadku tematyki bezpieczeństwa rzadko jest dobrym pomysłem. Wielokrotnie w ostatnich latach, a nawet miesiącach, słyszymy o wyciekach haseł, które po weryfikacji okazują się słabo albo wcale zabezpieczone.
Moje podejście do tematyki bezpieczeństwa zawsze zakłada maksymalizację wysiłków i środków, aby osiągnąć zadowalający rezultat, tym bardziej w kwestii tak newralgicznej, jak przechowywanie plików, które nierzadko mogą być dokumentami poufnymi.
Dlatego w dalszej części skupimy się na maksymalizacji efektu szyfrowania, a więc dla każdego pliku będzie generowana osobna para kluczy.
Na początek poprawimy kod javascript, który będzie pobierał przed każdym wysłaniem pliku na serwer nowy klucz prywatny i identyfikator pliku, który pomoże przypisać odpowiednie klucze.</p>
<pre tabindex="0"><code>function upload() {
    const file = document.getElementById(&#34;file&#34;).files[0];
    fetch(&#39;/upload&#39;, {method: &#39;HEAD&#39;}).then(function(response) {
      saveFile(
          file,
          response.headers.get(&#34;File-Public-Key&#34;),
          response.headers.get(&#34;File-Id&#34;)
      );
    });
}
async function saveFile (file, publicKeyString, fileId) {
  const reader = new FileReader();
  reader.addEventListener(&#34;load&#34;, () =&gt; {
        fetch(&#39;/upload&#39;, {
            method: &#39;PUT&#39;,
            body: cryptico.encrypt(
                   reader.result, publicKeyString
               ).cipher
        });
    }, false);
    if (file) {
       reader.readAsText(file);
    }
}
</code></pre><p>Metoda “/upload” [HEAD] powinna zwrócić w nagłówku oba potrzebne elementy które, zanim prześlemy zostaną zapisane po stronie serwera aplikacji np. w bazie danych. W tej sytuacji metoda “/upload” [HEAD] generuje parę kluczy i zapisuje ją w bazie. Gdy chcemy, aby plik po zaszyfrowaniu nie mógł zostać podmieniony i ponownie zaszyfrowany, możemy nie zapisywać kompletnej pary kluczy i pozostawić jedynie klucz prywatny, który będzie służył do odszyfrowania pliku.
Na potrzeby artykuły przyjmujemy, że przechowywane są tylko klucze prywatne, które są szyfrowane dodatkowo za pomocą algorytmu AES, dla którego klucz jest zapisany w pamięci serwera (plik, zapis w konfiguracji itp.). Ma to zabezpieczyć sam klucz prywatny przed dostępem osób nieuprawnionych, które mogą operować na bazie danych. W sytuacji, gdyby uzyskali dostęp do bazy danych, nie będą w stanie odszyfrować plików.</p>
<pre tabindex="0"><code>File-Public-Key: MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgGFxQyrqquJh+W/5wtrD3lrEWaCp
EDjcHreBGU37v58GB2i3Vl/3VBP1KUqlVmkre/iAXSOKKKnS2k8cqftPZMGf8+r6
BJKX7PJkKIEDkxBjReoaIZsibqGEKYF1ZLKmrvXlBO2+EyMvymv8A8QnJtHWdznw
yitAM25LKNRnPVWbAgMBAAE=
File-Id: 70ec0290-2768-42f4-af90-e378c524264d
</code></pre><pre tabindex="0"><code>|------------|--------------------|--------------------|
| Id         | File_ID            | File_Key           |
|------------|--------------------|--------------------| 
</code></pre><p>Po wprowadzeniu tych zmian w kodzie na serwerze powinien znajdować się już zaszyfrowany plik oraz klucz prywatny, służący do odszyfrowania w formie zaszyfrowanej zapisany w bazie aplikacji.
To jednak nie koniec samego procesu szyfrowania, ponieważ brakuje tu jeszcze danych pozwalających na odszyfrowanie. Co istotne w tym momencie żaden użytkownik nie może odszyfrować pliku. Aby funkcjonalność była kompletna, po załadowaniu pliku powinniśmy nadać odpowiednie “uprawnienia” dla właściciela pliku (osoby, która wgrywa plik na serwer), czyli najogólniej mówiąc, musimy zaszyfrować dla niego klucz prywatny pliku. W tym celu do zaszyfrowanego pliku dodamy wpis z kluczem prywatnym, który zostanie zaszyfrowany indywidualnym kluczem właściciela.
Sam pomysł nie jest nowy, podobny mechanizm został użyty w PGP, natomiast zamiast ponownie szyfrować plik, do którego zostaną dodane klucze, do pliku zaszyfrowanego dodamy osobne wpisy z kluczami użytkowników. Pozwoli to uniknąć potrzeby odszyfrowywania i ponownego szyfrowania, zarówno w kontekście dużych plików, jak również w kontekście bezpieczeństwa, ponieważ plik nie będzie odszyfrowywany i zapisywany na serwerze. Nasz plik będzie wyglądał mniej więcej w taki sposób:</p>
<pre tabindex="0"><code>-----BEGIN EFFIANA KEY-----
ID:24f1b2296b37c229789611a2293ef498bdde0787c0db3ae5ba216ac51a02c
KEY:/Oc8eQ6SJ52zxlIceORE20ZBqP+u4DhmY5i8rCeTv3GHnktDQBKxfZhqp8oAJKX3hlOvBApt54hZY4FupsxTpyKVbonleDETZcjNENs3Tk4GQqKOd9swADEWyQWC1DTOE+h20pEWldHCp9PKPw5wvg==
-----END EFFIANA KEY——
-----BEGIN EFFIANA MESSAGE-----
uAc6JIvkisAwvHXKjPuYmldoVC1sQWLY7J/Z0Ke1Dqy3yPHeMKzjyzzp8WSukWFCMG54A+9J/gdqDsA7lsScCdooSBNm7lEYuRLiopdzPEt72rqIQqKw2PxTvwCJWgfrDn3DZlFNgCs664OuF3S3mWK6cRoq9lybhCwsPCUGQPwDFHARXxMoEqucbgw5x30+UCNMzEODolWfJv0EgiOb4R55MydPOBVpUT9zRDJW95+mK4xQmjYYtr4kog1C436PdWzpMkNOtzOD49QhHS2y06jONZyD2tG4VMqjD+C9qSqK6tX/p/ZRRzNK9B2yqUALGhnH1wuSKrVNCGIIjXdk/0lCkoSCBEF+J0Nnx0erdjpqiU2AkbDtuRZNKliNIPGhj8p+61Mq4v8OO52PoLwa/rx+RvVlv8k5yJv6p1nHIDB1rnzAKdHz9sKIIY7UYeiX6Z7pGjQk5JEgQRWFnoGAoHAszgzhZe88SPAr+KDNadzxPk+U3+wuLng6w4Wn0ZxmQ=
-----END EFFIANA MESSAGE-----
</code></pre><p>Teraz plik jest kompletny, zawiera wszystkie potrzebne elementy, w tym identyfikator i klucz użytkownika, którymi będziemy się posługiwać przy odszyfrowywaniu pliku. Identyfikatorem może być adres email, unikalny numer użytkownika itp. W systemie Effiana używamy identyfikatora użytkownika, który przechowywany jest w postaci UUID, a dodatkowo jest on zapisany w postaci funkcji skrótu za pomocą algorytmu Keccak (SHA3).
Jak zatem wygląda proces tworzenia “EFFIANA KEY”?
Na samym początku generujemy parę kluczy dla użytkownika i pliku, gdyż na wstępie założyliśmy, że każdy plik będzie szyfrowany unikalnymi kluczami. Następnie dla zaszyfrowanego pliku pobieramy klucz prywatny, dokładnie ten sam, którego używamy do odszyfrowania. Teraz pozostało tylko odszyfrowanie klucza prywatnego za pomocą AES i zaszyfrowanie go za pomocą klucza publicznego wygenerowanego dla użytkownika. Dla bezpieczeństwa zapominamy o kluczu publicznym, a w bazie zapisujemy tylko klucz prywatny.
W tym miejscu możemy zastosować różne techniki zabezpieczenia tych kluczy, w tym np. dodatkowe szyfrowanie np. AES za pomocą przypisanego do użytkownika unikalnego tokenu. Możliwości jest wiele, natomiast najważniejsze, aby żadne klucze nie znalazły się w tym samym miejscu (serwerze, dysku itp.), w którym znajdują się zaszyfrowane nimi pliki.</p>
<blockquote>
<p>UWAGA: pliki zaszyfrowane w ten sposób nie będą mogły zostać odszyfrowane bez odpowiedniego klucza, a w przypadku skasowania ich z bazy, pliki staną się bezużyteczne i nie będzie możliwości ich odzyskania.
Aby temu zapobiec, można dla każdego pliku szyfrować klucz publiczny i wysyłać go do zewnętrznego kontenera. W systemie Effiana stosujemy w tym celu dedykowaną bazę danych, która umożliwia tylko i wyłącznie dodanie do tabeli kluczy, ale nie pozwala na ich usuwanie, edycję i pobieranie, dodatkowo co określony czas wszystkie klucze są zapisywane w zaszyfrowanej kopii bezpieczeństwa, która jest rozsyłana do kilku miejsc docelowych.
W przypadku bazy danych komenda może wyglądać tak:
MySQL: &ldquo;GRANT INSERT ON table TO ‘username’@&rsquo;localhost’;&rdquo;
PostgreSQL: &ldquo;GRANT INSERT ON table TO username;&rdquo;</p>
</blockquote>
<p>W następnych częściach zajmiemy się szyfrowaniem dużych plików (&gt;1GB), pobieraniem odszyfrowanych plików i rozszerzaniem osób uprawnionych do ich odszyfrowania.
Pierwotnie opublikowano na <a href="https://www.linkedin.com/posts/brandoriented_security-encryption-activity-6940972126568910849-P1GX/">LinkedIn</a></p>]]></content></item><item><title>Backup Schrödingera</title><link>https://labudzinski.com/posts/backup-schr%C3%B6dingera/</link><pubDate>Thu, 25 Apr 2019 09:45:32 +0200</pubDate><guid>https://labudzinski.com/posts/backup-schr%C3%B6dingera/</guid><description>&lt;p>Wyobraźmy sobie, że każdy robi regularnie kopię zapasową najważniejszych danych i przechowuje je w bezpiecznym miejscu.
Oczywiście już pierwsze zdanie jest nie prawdziwe, Zwyczajnie nie jestem w stanie uwierzyć, że istnieją osoby,
które nie posiadają kopii zapasowych swoich najważniejszych danych i świadomie narażają się na ich utratę.&lt;/p></description><content type="html"><![CDATA[<p>Wyobraźmy sobie, że każdy robi regularnie kopię zapasową najważniejszych danych i przechowuje je w bezpiecznym miejscu.
Oczywiście już pierwsze zdanie jest nie prawdziwe, Zwyczajnie nie jestem w stanie uwierzyć, że istnieją osoby,
które nie posiadają kopii zapasowych swoich najważniejszych danych i świadomie narażają się na ich utratę.</p>
<p>Natomiast wracając do kopii zapasowych, każdy je ma, prawda? A czy kiedykolwiek kopie, które posiadamy były testowane?
Czy mamy wiedzę o ich stanie, czy wiemy co w nich się zawiera, czy mamy pewność, że uda się je odzyskać?</p>
<p>W tym miejscu pojawia się tytułowa nazwa „Backup Schrödingera” - jest to oczywista analogia do <a href="https://pl.wikipedia.org/wiki/Kot_Schr%C3%B6dingera">Kota Schrödingera</a>.
Backup, który posiadamy jest w stanie nieoznaczonym. Nie wiemy co w nim jest, czy działa itp.
Taki dylemat logiczny pojawia się zawsze w związku z awarią, zanim nie zaczniemy przywracać kopii zapasowych.
Jest to mało komfortowe i bardzo stresujące, dlatego za każdym razem gdy wykonujecie kopię zapasową zadbajcie również o jej testy.</p>
<p>Koszt testowania kopii zapasowej jest niczym w porównaniu niedziałającym backupem. Dlatego polecam każdemu,
aby do swojej procedury tworzenia kopii dołączył zapis o testach, w tym o testowym przewracaniu backupu.</p>]]></content></item><item><title>Przechowywanie haseł w bazie</title><link>https://labudzinski.com/posts/przechowywanie-hase%C5%82-w-bazie/</link><pubDate>Tue, 19 Mar 2019 09:45:32 +0200</pubDate><guid>https://labudzinski.com/posts/przechowywanie-hase%C5%82-w-bazie/</guid><description>Od kilku lat obserwuje ciągłe wycieki haseł z baz danych różnych podmiotów, w tym tych największych. Nie ma w tym niczego dziwnego, bowiem złamanie zabezpieczeń w IT to tylko kwestia czasu i pieniędzy. Nie mniej jednak ze zmartwieniem i niekrytym smutkiem przyjmuję, że większość haseł przechowywanych obecnie w bazach danych nie jest dostatecznie zabezpieczona. O fakcie tym świadczy chociażby eksperyment studentów z Uniwersytetu Bonn,
w którym zlecili freelancerom stworzenie prostych aplikacji, które min.</description><content type="html"><![CDATA[<p>Od kilku lat obserwuje ciągłe wycieki haseł z baz danych różnych podmiotów, w tym tych największych. Nie ma w tym niczego dziwnego, bowiem złamanie zabezpieczeń w IT to tylko kwestia czasu i pieniędzy.
Nie mniej jednak ze zmartwieniem i niekrytym smutkiem przyjmuję, że większość haseł przechowywanych obecnie w bazach danych nie jest dostatecznie zabezpieczona. O fakcie tym świadczy chociażby <a href="https://net.cs.uni-bonn.de/fileadmin/user_upload/naiakshi/Naiakshina_Password_Study.pdf">eksperyment studentów z Uniwersytetu Bonn</a>,</p>
<p>w którym zlecili freelancerom stworzenie prostych aplikacji, które min. miały przechowywać hasła w bazie danych. Wyniki eksperymentu nie pozostawiają złudzeń, większość programistów nie dba o bezpieczeństwo, a co za tym idzie świadomie naraża zleceniobiorców na zagrożenie.</p>
<p>W dzisiejszym wpisie przedstawię sposób na szybka implementację bezpiecznego sposobu przechowywania haseł. Teoretycznie zastosowanie funkcji takich jak SHA powinno być bezpieczne, jednakże mają one swego rodzaju ułomność. Nowoczesne procesory, w tym specjalne klastry GPU są w stanie wygenerować miliardy hashy na sekundę, co niejako zwiększa szansę na to aby wygenerować wartość odpowiadającą hash hasła w bazie.</p>
<p>W ciągu kilku ostatnich lat rozwijałem metodę haszowania haseł, starając się aby sposób ich łamania był możliwie najtrudniejszy. W tym celu używam kombinacji kilku algorytmów.</p>
<p>Cały mechanizm opieram o argon2 mieszany z globalnym kluczem dodawanym do hasła.</p>
<p>Na początku hasło jest przekształcane za pomocą SHA512. Stosując SHA512, możemy szybko konwertować naprawdę długie hasła na stałą wartość 512 bitów, co pozwala na działanie algorytmu z tą samą prędkością dla każdej długości hasła. Następnie tak wygenerowany skrót przekazany jest wraz z solą, która jest unikalna dla każdego użytkownika, do algorytmu argon2. Ostateczny uzyskany skrót jest szyfrowany za pomocą AES256 przy użyciu klucza globalnego (wspólnego dla wszystkich), który przechowujemy w aplikacji.</p>
<p>Całość mechanizmy wygląda dość prosto:</p>
<blockquote>
<p>Hasło → SHA512 → argon2(unique salt) → AES256(global salt)</p>
</blockquote>
<p>Oczywiście istnieje ryzyko, że podczas włamania na serwer utracimy klucz globalny, jak również unikalne klucze dla każdego użytkownika, co może skompromitować działanie mechanizmu, nie mniej jednak odtworzenie tak zaszyfrowanych haseł może być wyjątkowo trudne.</p>
<p>Przykład: <a href="https://github.com/Effiana/password-bundle/blob/master/src/Security/PasswordEncoder.php">PasswordEncoder.php</a></p>
]]></content></item></channel></rss>